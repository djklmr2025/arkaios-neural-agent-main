// ---- ARKAIOS ENV LOADER (injected) ----
(function(){
  try {
    const fs = require('fs');
    const path = require('path');
    const candidates = [
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\.env',
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\.env.txt',
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\arkaios-core-api.onrender.com.env',
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\arkaios-service.env',
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\proxy.env',
      'C\\\:\\\Program Files\\\\NeuralAgent\\\\.env\\\\daemon.env'
    ];
    for (const p of candidates) {
      if (fs.existsSync(p)) {
        const txt = fs.readFileSync(p, 'utf8');
        txt.split(/\r?\n/).forEach(line=>{
          const m = line.match(/^\s*([A-Za-z0-9_]+)\s*=\s*(.+?)\s*$/);
          if (m) {
            const k=m[1]; const v=m[2].replace(/^['"]|['"]$/g,'');
            if (!process.env[k]) process.env[k]=v;
          }
        });
        if (!txt.match(/=/) && !process.env.NEURALAGENT_USER_ACCESS_TOKEN) {
          const token = txt.trim();
          if (token.length>0) process.env.NEURALAGENT_USER_ACCESS_TOKEN = token;
        }
      }
    }
    process.env.NEURALAGENT_API_URL = process.env.NEURALAGENT_API_URL
      || process.env.ARKAIOS_GATEWAY_URL
      || process.env.ARKAIOS_API_URL
      || process.env.GATEWAY_URL
      || process.env.API_URL
      || process.env.BASE_URL
      || process.env.PROXY_URL
      || process.env.ARKAIOS_CORE_API_URL
      || 'http://127.0.0.1:8000';
  } catch (e) { /* ignore */ }
})();
// ---- END ARKAIOS ENV LOADER ----\nimport { app, BrowserWindow, shell, Menu, ipcMain, dialog, screen, nativeImage } from 'electron';
import path from 'path';
import electronUpdater from 'electron-updater';
import { fileURLToPath } from 'url';
import isDev from 'electron-is-dev';
import Store from 'electron-store';
import constants from './electron/utils/constants.js';
import { spawn, exec, execSync } from 'child_process';
import { generatePKCE } from './electron/utils/oauth.js';
import express from 'express';
import kill from 'tree-kill';
import url from 'url';
import http from 'http';
import { v4 as uuidv4 } from 'uuid';
import { setupBackgroundMode, isBackgroundModeReady } from './electron/utils/wslSetup.js';
import { getOptimalAgentBinary, cleanupExtractedBinary } from './electron/utils/agentPath.js';
import MacOSPermissions from './electron/utils/macos-permissions.js';

const { autoUpdater } = electronUpdater;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const store = new Store();
const permissions = new MacOSPermissions();

let mainWindow;
let overlayWindow;
let aiagentProcess;
let backgroundAuthWindow;
let bgAuthProcess;
let bgAgentWindow;
let bgSetupWindow;
let readyToClose = false;
let overlayHideTimeout = null;

// ---- OBSERVABILITY: simple telemetry buffer for Trae preview ----
// Exposes last action, latency, errors, suggestions, etc. via local HTTP
let obs = {
  lastAction: null,
  lastLatencyMs: null,
  lastError: null,
  lastSuggestions: null,
  lastThreadId: null,
  lastBackgroundMode: null,
  lastAiResponse: null,
};
// Persistent micro-server to visualize state in Trae viewer
try {
  const obsApp = express();
  obsApp.get('/status', (req, res) => {
    res.json({
      ok: true,
      lastAction: obs.lastAction,
      lastLatencyMs: obs.lastLatencyMs,
      lastError: obs.lastError,
      lastThreadId: obs.lastThreadId,
      lastBackgroundMode: obs.lastBackgroundMode,
    });
  });
  obsApp.get('/overlay', (req, res) => {
    res.json({
      suggestions: obs.lastSuggestions,
      aiResponse: obs.lastAiResponse,
    });
  });
  const OBS_PORT = parseInt(process.env.OBS_PORT || '7777');
  obsApp.listen(OBS_PORT, () => {
    console.log(`[OBS] Listening on http://localhost:${OBS_PORT}/ (status, overlay)`);
  });
} catch (e) {
  console.warn('[OBS] Failed to start observability server:', e?.message || e);
}

// ---- ARKAIOS LOCAL AUTOLOGIN (optional) ----
function b64urlFromJSON(obj) {
  return Buffer.from(JSON.stringify(obj))
    .toString('base64')
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
}

function ensureArkaiosAutologin() {
  try {
    const forceLocal = (process.env.ARKAIOS_AUTOLOGIN === '1') || (process.env.ARKAIOS_LOCAL_MODE === '1');
    const email = process.env.ARKAIOS_EMAIL || 'arkaios@arkaios.god';
    const displayName = process.env.ARKAIOS_DISPLAY_NAME || 'Guardian del Fuejo';
    const localPassword = process.env.ARKAIOS_PASSWORD || 'Fuejo_Guardian_2025!';

    const existingTok = store.get(constants.ACCESS_TOKEN_STORE_KEY);
    if (!existingTok || forceLocal) {
      const header = { alg: 'HS256', typ: 'JWT' };
      const payload = {
        sub: 'arkaios-local',
        name: displayName,
        email,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 315576000 // ~10 años
      };
      const token = `${b64urlFromJSON(header)}.${b64urlFromJSON(payload)}.ARKAIOS`;
      store.set(constants.ACCESS_TOKEN_STORE_KEY, token);
      store.set(constants.REFRESH_TOKEN_STORE_KEY, 'ARKAIOS_LOCAL_REFRESH');
      try { store.set('_NA_LOCAL_CREDENTIALS', { email, password: localPassword, displayName }); } catch {}
      // También rellenamos variable de entorno por si algún subproceso la usa
      process.env.NEURALAGENT_USER_ACCESS_TOKEN = token;
      console.log('[Arkaios] Autologin local aplicado para:', displayName, email);
    }
  } catch (e) {
    console.warn('[Arkaios] Falló autologin local:', e?.message || e);
  }
}

function applyArkaiosUIHints(win) {
  const email = process.env.ARKAIOS_EMAIL || 'arkaios@arkaios.god';
  const displayName = process.env.ARKAIOS_DISPLAY_NAME || 'Guardian del Fuejo';
  // Pequeña inyección para ocultar botones sensibles y forzar nombre visible
  const script = `(() => {
    try {
      const name = ${JSON.stringify(displayName)};
      const email = ${JSON.stringify(email)};
      const localAccess = ${JSON.stringify(store.get(constants.ACCESS_TOKEN_STORE_KEY) || '')};
      const localRefresh = ${JSON.stringify(store.get(constants.REFRESH_TOKEN_STORE_KEY) || '')};

      // Ocultar acciones de cuenta que no aplican en modo local
      const hideByText = (regex) => {
        const nodes = Array.from(document.querySelectorAll('button, a, div, span'));
        nodes.forEach(n => {
          const t = (n.textContent || '').trim();
          if (regex.test(t)) {
            n.style.display = 'none';
          }
        });
      };
      hideByText(/Upgrade to Pro/i);
      hideByText(/Logout/i);
      hideByText(/^Login$/i);

      // Reemplazar nombre visible si la UI muestra uno
      const candidates = Array.from(document.querySelectorAll('div, span, p, a, h1, h2, h3'));
      for (const el of candidates) {
        const t = (el.textContent || '').trim();
        if (!t) continue;
        // Si aparece el correo o un nombre anterior, reemplazar
        if (t.includes(email) || /@/.test(t) || /[A-ZÁÉÍÓÚÑ][a-záéíóúñ]+\s+[A-ZÁÉÍÓÚÑ][a-záéíóúñ]+/.test(t)) {
          el.textContent = name;
          break;
        }
      }

      // Interceptar fetch/XHR para el flujo de login y perfil, devolviendo éxito local
      try {
        const originalFetch = window.fetch;
        window.fetch = async (url, options = {}) => {
          const urlStr = (typeof url === 'string') ? url : (url?.toString?.() || '');
          const isNA = /getneuralagent|arkaios|localhost|127\.0\.0\.1/i.test(urlStr);
          const isLogin = /auth\/login|login/i.test(urlStr);
          const isProfile = /\/me|profile|users\/(me|profile)/i.test(urlStr);
          if (isNA && (isLogin || isProfile)) {
            const headers = { 'Content-Type': 'application/json' };
            if (isLogin) {
              // Simular respuesta de login devolviendo tokens locales
              const body = JSON.stringify({ accessToken: localAccess, refreshToken: localRefresh, user: { id: 'arkaios-local', name, email } });
              // Empujar token al bridge
              try { if (window.electronAPI?.setToken) window.electronAPI.setToken(localAccess); } catch {}
              try { localStorage.setItem('_NA_ACCESS_TOK', localAccess); localStorage.setItem('_NA_REFRESH_TOK', localRefresh); } catch {}
              // Forzar navegación al Home
              try { location.hash = '#/'; window.dispatchEvent(new Event('popstate')); } catch {}
              return new Response(body, { status: 200, headers });
            }
            if (isProfile) {
              const body = JSON.stringify({ id: 'arkaios-local', name, email, plan: 'local' });
              return new Response(body, { status: 200, headers });
            }
          }
          return originalFetch(url, options);
        };
      } catch {}

      // Interceptar envío de formulario de Login para bypass local sin red
      try {
        const form = document.querySelector('form');
        if (form) {
          form.addEventListener('submit', (ev) => {
            try { ev.preventDefault(); } catch {}
            try { if (window.electronAPI?.setToken) window.electronAPI.setToken(localAccess); } catch {}
            try { localStorage.setItem('_NA_ACCESS_TOK', localAccess); localStorage.setItem('_NA_REFRESH_TOK', localRefresh); } catch {}
            try { location.hash = '#/'; window.dispatchEvent(new Event('popstate')); } catch {}
            // Ocultar el contenedor de login si persiste
            try { const loginTitle = Array.from(document.querySelectorAll('h1,h2,h3,p,span')).find(n=>/Login to NeuralAgent/i.test(n.textContent||'')); if (loginTitle) loginTitle.closest('div')?.remove(); } catch {}
          }, { once: true });
        }
        // Si existe botón Login, enganchar click como fallback
        const loginBtn = Array.from(document.querySelectorAll('button')).find(b => /login/i.test((b.textContent||'')));
        if (loginBtn) {
          loginBtn.addEventListener('click', (ev) => {
            try { ev.preventDefault(); ev.stopPropagation(); } catch {}
            try { if (window.electronAPI?.setToken) window.electronAPI.setToken(localAccess); } catch {}
            try { localStorage.setItem('_NA_ACCESS_TOK', localAccess); localStorage.setItem('_NA_REFRESH_TOK', localRefresh); } catch {}
            try { location.hash = '#/'; window.dispatchEvent(new Event('popstate')); } catch {}
            try { const loginRoot = loginBtn.closest('div[role="dialog"], .login, .auth'); if (loginRoot) loginRoot.style.display = 'none'; } catch {}
          }, { once: true });
        }
      } catch {}
    } catch (e) {}
  })();`;
  try { win.webContents.executeJavaScript(script); } catch {}
}

function ensureDeviceId() {
  let deviceId = store.get(constants.DEVICE_ID_STORE_KEY);
  if (!deviceId) {
    deviceId = uuidv4();
    store.set(constants.DEVICE_ID_STORE_KEY, deviceId);
    console.log(`[Device ID created]: ${deviceId}`);
  } else {
    console.log(`[Device ID exists]: ${deviceId}`);
  }
}

autoUpdater.autoDownload = false;
autoUpdater.autoInstallOnAppQuit = true;

autoUpdater.setFeedURL({
  provider: 'generic',
  url: 'https://api.getneuralagent.com/apps/neuralagent_desktop/updates/'
});

function setupAutoUpdater(window) {
  autoUpdater.on('checking-for-update', () => {
    console.log('Checking for update...');
  });

  autoUpdater.on('update-available', (info) => {
    console.log('Update available:', info);
    window.webContents.send('update-available', {
      version: info.version,
      releaseDate: info.releaseDate,
      releaseNotes: info.releaseNotes,
    });
  });

  autoUpdater.on('update-not-available', (info) => {
    console.log('Update not available');
    window.webContents.send('update-not-available');
  });

  autoUpdater.on('error', (error) => {
    console.error('AutoUpdater error:', error);
    window.webContents.send('update-error', error.message);
  });

  autoUpdater.on('download-progress', (progressObj) => {
    window.webContents.send('download-progress', {
      percent: progressObj.percent,
      transferred: progressObj.transferred,
      total: progressObj.total,
      bytesPerSecond: progressObj.bytesPerSecond,
    });
  });

  autoUpdater.on('update-downloaded', (info) => {
    console.log('Update downloaded');
    window.webContents.send('update-downloaded', info);
  });
}

ipcMain.handle('check-for-updates', async () => {
  try {
    const result = await autoUpdater.checkForUpdates();
    return { success: true, updateInfo: result?.updateInfo };
  } catch (error) {
    console.error('Check for updates error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('download-update', async () => {
  try {
    await autoUpdater.downloadUpdate();
    return { success: true };
  } catch (error) {
    console.error('Download update error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('install-update', () => {
  autoUpdater.quitAndInstall(false, true);
});

ipcMain.handle('get-app-version', () => {
  return app.getVersion();
});

ipcMain.handle('open-external', async (_, url) => {
  shell.openExternal(url);
});

ipcMain.on('set-token', (_, token) => {
  store.set(constants.ACCESS_TOKEN_STORE_KEY, token);
  if (!overlayWindow) {
    createOverlayWindow();
  }
});

ipcMain.handle('get-token', () => store.get(constants.ACCESS_TOKEN_STORE_KEY));
ipcMain.on('delete-token', () => {
  store.delete(constants.ACCESS_TOKEN_STORE_KEY);
  if (overlayWindow) {
    overlayWindow.close();
  }
});
ipcMain.on('set-refresh-token', (_, token) => store.set(constants.REFRESH_TOKEN_STORE_KEY, token));
ipcMain.handle('get-refresh-token', () => store.get(constants.REFRESH_TOKEN_STORE_KEY));
ipcMain.on('delete-refresh-token', () => store.delete(constants.REFRESH_TOKEN_STORE_KEY));
ipcMain.handle('check-permissions', async () => {
  return await permissions.checkAllPermissions();
});

ipcMain.handle('request-accessibility', async () => {
  return await permissions.requestAccessibility();
});

ipcMain.handle('request-screen-recording', async () => {
  return await permissions.requestScreenRecording();
});

ipcMain.handle('open-system-preferences', async (event, permission) => {
  return await permissions.openSystemPreferences(permission);
});

ipcMain.handle('get-app-management-shown', () => {
  return store.get(constants.APP_MANAGEMENT_SHOWN_KEY, 'false');
});

ipcMain.on('set-app-management-shown', () => {
  store.set(constants.APP_MANAGEMENT_SHOWN_KEY, 'true');
});


ipcMain.on('expand-overlay', (_, hasSuggestions) => {
  console.log("[Main Process] Received 'expand-overlay' IPC message.");
  expandMinimizeOverlay(true, hasSuggestions);
});

ipcMain.on('set-dark-mode', (_, isDarkMode) => {
  store.set(constants.DARK_MODE_STORE_KEY, isDarkMode.toString());
  if (overlayWindow) {
    overlayWindow.reload();
  }
});
ipcMain.handle('is-dark-mode', () => store.get(constants.DARK_MODE_STORE_KEY));

ipcMain.handle('get-last-background-mode-value', () => store.get(constants.LAST_BACKGROUND_MODE_VALUE));

// Handle MINIMIZE request
ipcMain.on('minimize-overlay', () => {
  console.log("[Main Process] Received 'minimize-overlay' IPC message.");
  expandMinimizeOverlay(false);
});

ipcMain.handle('check-background-ready', () => {
  const isWindows = process.platform === 'win32';
  const isMac = process.platform === 'darwin';
  if (isWindows) {
    return isBackgroundModeReady(); 
  }
  return true;
});

ipcMain.handle('start-background-setup', async () => {
  const isWindows = process.platform === 'win32';
  const isMac = process.platform === 'darwin';
  if (isWindows) {
    if (bgSetupWindow && !bgSetupWindow.isDestroyed()) {
      bgSetupWindow.focus();
      return;
    }

    bgSetupWindow = new BrowserWindow({
      width: 600,
      height: 300,
      title: 'Setting up Background Mode',
      resizable: false,
      modal: true,
      icon: path.join(__dirname, 'assets', process.platform === 'win32' ? 'icon.ico' : 'icon.png'),
      webPreferences: {
        preload: path.join(__dirname, 'electron', 'preload.js'),
        contextIsolation: true,
      },
    });

    const bgSetupUrl = isDev
      ? 'http://localhost:6763/#/background-setup'
      : `file://${path.join(__dirname, 'neuralagent-app', 'build', 'index.html')}#/background-setup`;

    bgSetupWindow.loadURL(bgSetupUrl);

    bgSetupWindow.on('closed', () => {
      bgSetupWindow = null;
    });

    const defaultErr = 'Setup Failed: Please ensure you have Windows 10 or higher and that virtualization is enabled in BIOS.';

    let result = { success: false, error: defaultErr };

    try {
      result = await setupBackgroundMode({
        onStatus: (msg) => {
          if (!bgSetupWindow?.isDestroyed()) {
            bgSetupWindow.webContents.send('setup-status', msg);
          }
        },
        onProgress: (pct) => {
          if (!bgSetupWindow?.isDestroyed()) {
            bgSetupWindow.webContents.send('setup-progress', pct);
          }
        },
      });
    } catch (err) {
      console.error('❌ Setup failed:', err);
      result = {
        success: false,
        error: err?.message || defaultErr,
      };
    }

    if (bgSetupWindow && !bgSetupWindow.isDestroyed()) {
      bgSetupWindow.webContents.send('setup-complete', result);
    }

    if (result.success) {
      launchBackgroundAuthWindow();
    }

    return result;
  }
});

// Hide overlay temporarily during agent mouse actions
ipcMain.on('hide-overlay-temporarily', (_, duration = 3000) => {
  if (!overlayWindow || overlayWindow.isDestroyed()) return;
  
  console.log(`[Overlay] Hiding temporarily for ${duration}ms`);
  
  // Clear any existing timeout
  if (overlayHideTimeout) {
    clearTimeout(overlayHideTimeout);
  }
  
  // Hide the overlay
  overlayWindow.hide();
  
  // Set timeout to show it again WITHOUT taking focus
  overlayHideTimeout = setTimeout(() => {
    if (overlayWindow && !overlayWindow.isDestroyed()) {
      // Show overlay without stealing focus
      overlayWindow.showInactive();
      console.log('[Overlay] Restored after temporary hide (no focus)');
    }
    overlayHideTimeout = null;
  }, duration);
});

// Manual overlay show/hide controls
ipcMain.on('show-overlay', () => {
  if (overlayWindow && !overlayWindow.isDestroyed()) {
    overlayWindow.showInactive(); // Don't steal focus
  }
});

ipcMain.on('hide-overlay', () => {
  if (overlayWindow && !overlayWindow.isDestroyed()) {
    overlayWindow.hide();
  }
});

// Make overlay click-through during agent operations
ipcMain.on('set-overlay-click-through', (_, clickThrough = true) => {
  if (overlayWindow && !overlayWindow.isDestroyed()) {
    try {
      overlayWindow.setIgnoreMouseEvents(clickThrough);
      console.log(`[Overlay] Click-through mode: ${clickThrough}`);
    } catch (error) {
      console.warn('[Overlay] setIgnoreMouseEvents not supported:', error);
    }
  }
});


ipcMain.handle('get-suggestions', async (_, baseURL) => {
  return new Promise((resolve, reject) => {
    const _tStart = Date.now();
    obs.lastAction = 'get-suggestions';

    const isWindows = process.platform === 'win32';
    const isMac = process.platform === 'darwin';

    // const suggestor = spawn(isWindows ? './aiagent/venv/Scripts/python' : './aiagent/venv/bin/python', ['./aiagent/main.py'], {
    //   env: {
    //     ...process.env,
    //     NEURALAGENT_API_URL: process.env.NEURALAGENT_API_URL || "http://127.0.0.1:8000",
    //     NEURALAGENT_USER_ACCESS_TOKEN: (process.env.NEURALAGENT_USER_ACCESS_TOKEN || ""),
    //     NEURALAGENT_AGENT_MODE: 'suggestor',
    //   },
    // });

    const suggestorPath = getOptimalAgentBinary();

    const suggestor = spawn(suggestorPath, [], {
      env: {
        ...process.env,
        NEURALAGENT_API_URL: process.env.NEURALAGENT_API_URL || "http://127.0.0.1:8000",
        NEURALAGENT_USER_ACCESS_TOKEN: (process.env.NEURALAGENT_USER_ACCESS_TOKEN || ""),
        NEURALAGENT_AGENT_MODE: 'suggestor',
      },
    });

    let output = '';
    let errorOutput = '';

    suggestor.stdout.on('data', (data) => {
      output += data.toString();
    });

    suggestor.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    suggestor.on('close', (code) => {
      if (code === 0) {
        try {
          const result = JSON.parse(output);
          obs.lastSuggestions = result;
          obs.lastLatencyMs = Date.now() - _tStart;
          obs.lastError = null;
          resolve(result);
        } catch (err) {
          console.error('❌ Failed to parse suggestor output:', output);
          obs.lastLatencyMs = Date.now() - _tStart;
          obs.lastError = err?.message || 'Failed to parse suggestor output';
          reject(err);
        }
      } else {
        console.error('❌ Suggestor exited with error:', errorOutput);
        obs.lastLatencyMs = Date.now() - _tStart;
        obs.lastError = errorOutput || 'Suggestor failed';
        reject(new Error('Suggestor failed'));
      }
    });
  });
});

ipcMain.on('launch-ai-agent', async (_, baseURL, threadId, backgroundMode, aiResponse) => {
  obs.lastAction = 'launch-ai-agent';
  obs.lastThreadId = threadId;
  obs.lastBackgroundMode = backgroundMode;
  obs.lastAiResponse = aiResponse;
  const isWindows = process.platform === 'win32';
  const isMac = process.platform === 'darwin';

  store.set(constants.LAST_BACKGROUND_MODE_VALUE, backgroundMode.toString());

  if (!backgroundMode || isMac) {
    // aiagentProcess = spawn(isWindows ? './aiagent/venv/Scripts/python' : './aiagent/venv/bin/python', ['./aiagent/main.py'], {
    //   env: {
    //     ...process.env,
    //     NEURALAGENT_API_URL: process.env.NEURALAGENT_API_URL || "http://127.0.0.1:8000",
    //     NEURALAGENT_THREAD_ID: threadId,
    //     NEURALAGENT_USER_ACCESS_TOKEN: (process.env.NEURALAGENT_USER_ACCESS_TOKEN || ""),
    //     NEURALAGENT_AGENT_MODE: backgroundMode ? 'background_agent' : 'agent',
    //     PYTHONUTF8: '1',
    //   },
    // });

    mainWindow?.minimize();

    const agentPath = getOptimalAgentBinary();
    
    aiagentProcess = spawn(agentPath, [], {
      env: {
        ...process.env,
        NEURALAGENT_API_URL: process.env.NEURALAGENT_API_URL || "http://127.0.0.1:8000",
        NEURALAGENT_THREAD_ID: threadId,
        NEURALAGENT_USER_ACCESS_TOKEN: (process.env.NEURALAGENT_USER_ACCESS_TOKEN || ""),
        NEURALAGENT_AGENT_MODE: backgroundMode ? 'background_agent' : 'agent',
      },
    });
  } else {
    if (isWindows) {
      // VERY IMPORTANT
      const envVars = {
        ...process.env,
        NEURALAGENT_API_URL: process.env.NEURALAGENT_API_URL || "http://127.0.0.1:8000", // 'http://192.168.8.101:8000',
        NEURALAGENT_THREAD_ID: threadId,
        NEURALAGENT_USER_ACCESS_TOKEN: (process.env.NEURALAGENT_USER_ACCESS_TOKEN || ""),
        SKIP_LLM_API_KEY_VERIFICATION: 'true',
        PYTHONUTF8: '1',
      };

      const shellCommand = Object.entries(envVars)
        .map(([k, v]) => `${k}="${v}"`).join(' ') + ' bash /agent/launch_bg_agent.sh';

      aiagentProcess = spawn('wsl', ['-d', 'NeuralOS', '--', 'bash', '-c', shellCommand]);

      launchBackgroundAgentWindow();
    }
  }

  mainWindow?.webContents.send('ai-agent-launch', threadId, backgroundMode, aiResponse);
  overlayWindow?.webContents.send('ai-agent-launch', threadId, backgroundMode, aiResponse);
  expandMinimizeOverlay(true, false);

  aiagentProcess.stdout.on('data', (data) => console.log(`[Agent stdout]: ${data}`));
  aiagentProcess.stderr.on('data', (data) => console.error(`[Agent stderr]: ${data}`));

  aiagentProcess.on('error', err => {
    console.error('❌  Agent process failed to start:', err);
    mainWindow?.webContents.send('trigger-cancel-all-tasks');
  });

  aiagentProcess.on('exit', (code, signal) => {
    console.log(`[Agent exited with code ${code}]`);
    if (bgAgentWindow) {
      bgAgentWindow.close();
    }
    cleanupBGAgent();
    if (mainWindow?.isMinimized()) {
      mainWindow.restore();
    }
    if (mainWindow) {
      mainWindow.focus();
    }
    mainWindow?.webContents.send('ai-agent-exit');
    overlayWindow?.webContents.send('ai-agent-exit');

    if (code !== 0 || signal) {
      mainWindow?.webContents.send('trigger-cancel-all-tasks');
    }
    aiagentProcess = null;
  });
});

ipcMain.on('stop-ai-agent', () => {
  if (aiagentProcess && !aiagentProcess.killed) {
    kill(aiagentProcess.pid, 'SIGKILL', (err) => {
      if (err) console.error('❌ Failed to kill agent:', err);
      else console.log('[✅ Agent forcibly stopped]');
    });
  }
  aiagentProcess = null;
  cleanupBGAgent();
});

const GOOGLE_CLIENT_ID = '296264060339-jamhdgfckblr0qgq360t5ok4e1kede35.apps.googleusercontent.com';
const REDIRECT_URI = 'http://127.0.0.1:36478';

function openUrlInBrowser(targetUrl) {
  const platform = process.platform;
  const command =
    platform === 'win32'
      ? `start "" "${targetUrl}"`
      : platform === 'darwin'
      ? `open "${targetUrl}"`
      : `xdg-open "${targetUrl}"`;
  exec(command);
}

ipcMain.handle('login-with-google', async () => {
  const { codeVerifier, codeChallenge } = generatePKCE();

  const authUrl = `https://accounts.google.com/o/oauth2/v2/auth` +
    `?client_id=${GOOGLE_CLIENT_ID}` +
    `&redirect_uri=${encodeURIComponent(REDIRECT_URI)}` +
    `&response_type=code` +
    `&scope=openid%20email%20profile` +
    `&code_challenge=${codeChallenge}` +
    `&code_challenge_method=S256` +
    `&access_type=offline`;

  openUrlInBrowser(authUrl);

  const appExpress = express();

  return new Promise((resolve, reject) => {
    const server = appExpress.listen(36478, () => {
      console.log('Listening for Google OAuth callback...');
    });

    appExpress.get('/', (req, res) => {
      const code = req.query.code;
      if (!code) {
        res.send('Login failed.');
        server.close();
        return reject('No code received');
      }

      res.send('Login successful! You can close this window.');
      server.close();
      resolve({ code, codeVerifier });
    });
  });
});

const createAppMenu = () => {
  let neuralAgentSubmenu = [];
  const isWindows = process.platform === 'win32';
  if (isWindows) {
    neuralAgentSubmenu.push(
      {
        label: 'Background Mode Authentication',
        click: () => {
          if ((aiagentProcess && !aiagentProcess.killed) || (bgAuthProcess && !bgAuthProcess.killed)) {
            return;
          }
          launchBackgroundAuthWindow();
        },
      },
      { type: 'separator' }
    );
  }
  neuralAgentSubmenu.push(
    {
      label: 'Logout',
      click: () => {
        if (overlayWindow) {
          overlayWindow.close();
        }
        mainWindow?.webContents.send('trigger-logout');
      },
    },
    { type: 'separator' },
    {
      label: 'Quit',
      role: 'quit'
    },
  );
  const template = [
    {
      label: 'NeuralAgent',
      submenu: neuralAgentSubmenu,
    },
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        { role: 'selectall' }
      ]
    },
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        // { role: 'toggleDevTools' },
        { type: 'separator' },
        { role: 'resetZoom' },
        { role: 'zoomIn' },
        { role: 'zoomOut' },
        { type: 'separator' },
        { role: 'togglefullscreen' }
      ]
    },
    {
      label: 'Window',
      submenu: [
        { role: 'minimize' },
        { role: 'close' }
      ]
    }
  ];
  Menu.setApplicationMenu(Menu.buildFromTemplate(template));
};

function startBackgroundAuthServices() {
  bgAuthProcess = spawn('wsl', ['-d', 'NeuralOS', '--', 'bash', '/agent/background_mode_authentication.sh']);

  bgAuthProcess.stdout.on('data', data => {
    console.log(`[BG Auth]: ${data.toString()}`);
  });

  bgAuthProcess.stderr.on('data', data => {
    console.error(`[BG Auth ERROR]: ${data.toString()}`);
  });
}

function cleanupBackgroundAuthServices() {
  try {
    execSync('wsl -d NeuralOS -- bash /agent/background_mode_authentication_cleanup.sh');
    console.log('[BG Auth]: Cleanup script executed.');
  } catch (err) {
    console.error('[BG Auth]: Cleanup failed:', err);
  }

  if (bgAuthProcess) {
    if (!bgAuthProcess.killed) {
      bgAuthProcess.kill('SIGKILL');
    }
  }
  bgAuthProcess = null;
}

function cleanupBGAgent() {
  const isWindows = process.platform === 'win32';
  if (!isWindows) {
    return;
  }
  try {
    execSync('wsl -d NeuralOS -- bash /agent/stop_bg_agent.sh');
    console.log('[BG Agent]: Cleanup script executed.');
  } catch (err) {
    console.error('[BG Agent]: Cleanup failed:', err);
  }

  if (aiagentProcess) {
    if (!aiagentProcess.killed) {
      aiagentProcess.kill('SIGKILL');
    }
  }
}

function waitForNoVNCPortReady(port, timeout = 10000, interval = 300) {
  const deadline = Date.now() + timeout;

  return new Promise((resolve, reject) => {
    const check = () => {
      const req = http.get({ hostname: '127.0.0.1', port, path: '/', timeout: 1000 }, (res) => {
        res.destroy();
        resolve(true); // Port is ready
      });

      req.on('error', (err) => {
        if (Date.now() > deadline) return reject(new Error('Timed out waiting for noVNC'));
        setTimeout(check, interval);
      });

      req.end();
    };

    check();
  });
}

function launchBackgroundAuthWindow() {
  if (backgroundAuthWindow) return;

  startBackgroundAuthServices();

  waitForNoVNCPortReady(39742, 20000)
    .then(() => {
      backgroundAuthWindow = new BrowserWindow({
        width: 1350,
        height: 780,
        title: 'NeuralAgent Background Auth',
        icon: path.join(__dirname, 'assets', process.platform === 'win32' ? 'icon.ico' : 'icon.png'),
        webPreferences: {
          contextIsolation: true,
          nodeIntegration: false,
          preload: path.join(__dirname, 'electron', 'preload.js'),
        },
      });

      const reactURL = isDev
        ? 'http://localhost:6763/#/background-auth'
        : `file://${path.join(__dirname, 'neuralagent-app', 'build', 'index.html')}#/background-auth`;

      backgroundAuthWindow.loadURL(reactURL);

      backgroundAuthWindow.on('closed', () => {
        cleanupBackgroundAuthServices();
        backgroundAuthWindow = null;
      });
    })
    .catch((err) => {
      console.error('❌ noVNC failed to start:', err);
      cleanupBackgroundAuthServices();
    });
}

function launchBackgroundAgentWindow() {
  if (bgAgentWindow) return;

  waitForNoVNCPortReady(39742, 20000)
    .then(() => {
      bgAgentWindow = new BrowserWindow({
        width: 1350,
        height: 780,
        title: 'NeuralAgent Background Task',
        icon: path.join(__dirname, 'assets', process.platform === 'win32' ? 'icon.ico' : 'icon.png'),
        webPreferences: {
          contextIsolation: true,
          nodeIntegration: false,
          preload: path.join(__dirname, 'electron', 'preload.js'),
        },
      });

      const reactURL = isDev
        ? 'http://localhost:6763/#/background-task'
        : `file://${path.join(__dirname, 'neuralagent-app', 'build', 'index.html')}#/background-task`;

      bgAgentWindow.loadURL(reactURL);

      bgAgentWindow.on('closed', () => {
        bgAgentWindow = null;
      });
    })
    .catch((err) => {
      console.error('noVNC failed to start:', err);
    });
}

function createWindow() {
  if (mainWindow) return;
  mainWindow = new BrowserWindow({
    width: 1050,
    height: 750,
    icon: path.join(__dirname, 'assets', process.platform === 'win32' ? 'icon.ico' : 'icon.png'),
    webPreferences: {
      preload: path.join(__dirname, 'electron', 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  const startURL = isDev
    ? 'http://localhost:6763'
    : url.format({
        pathname: path.join(__dirname, 'neuralagent-app', 'build', 'index.html'),
        protocol: 'file:',
        slashes: true,
      });

  mainWindow.loadURL(startURL);

  mainWindow.on('close', async (e) => {
    if (readyToClose) return;

    e.preventDefault();
    if (mainWindow?.webContents) {
      mainWindow?.webContents.send('trigger-cancel-all-tasks');
    }

    ipcMain.once('cancel-all-tasks-done', () => {
      readyToClose = true;
      mainWindow.close();
    });
  });

  mainWindow.on('closed', () => {
    mainWindow = null;

    if (overlayWindow && !overlayWindow.isDestroyed()) {
      overlayWindow.close();
    }
    if (bgAgentWindow && !bgAgentWindow.isDestroyed()) {
      bgAgentWindow.close();
    }
    if (bgSetupWindow && !bgSetupWindow.isDestroyed()) {
      bgSetupWindow.close();
    }
    if (backgroundAuthWindow && !backgroundAuthWindow.isDestroyed()) {
      backgroundAuthWindow.close();
    }
  });
}

function createOverlayWindow() {
  if (overlayWindow) return;

  const windowWidth = 60;
  const windowHeight = 60;
  const margin = 25;

  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } = primaryDisplay.workArea;

  const xPos = screenWidth - windowWidth - margin;
  const yPos = screenHeight - windowHeight - margin;

  overlayWindow = new BrowserWindow({
    width: 60,
    height: 60,
    x: xPos,
    y: yPos,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: true,
    webPreferences: {
      preload: path.join(__dirname, 'electron', 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  try {
    overlayWindow.setContentProtection(true);
  } catch (e) {
    console.warn('[Overlay] setContentProtection not available:', e);
  }

  const overlayURL = isDev
    ? 'http://localhost:6763/#/overlay'
    : `file://${path.join(__dirname, 'neuralagent-app', 'build', 'index.html')}#/overlay`;

  overlayWindow.loadURL(overlayURL);

  overlayWindow.on('closed', () => {
    overlayWindow = null;
  });
}

function expandMinimizeOverlay(expanded, hasSuggestions = false) {
  if (!overlayWindow || overlayWindow.isDestroyed()) return;

  const W = expanded ? 350 : 60;
  const H = expanded ? (hasSuggestions ? 380 : 500) : 60;
  const M = 25;
  const { width: SW, height: SH } = screen.getPrimaryDisplay().workArea;
  const X = SW - W - M;
  const Y = SH - H - M;

  overlayWindow.setBounds({ x: X, y: Y, width: W, height: H }, true);

  // Ensure overlay is visible if not temporarily hidden, but don't steal focus
  if (!overlayHideTimeout) {
    overlayWindow.showInactive();
  }
}

const gotLock = app.requestSingleInstanceLock();
if (!gotLock) {
  app.quit();
} else {
  app.on('second-instance', () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });
}

app.whenReady().then(() => {
  const devIconPath = path.join(__dirname, 'assets', 'icon.png');
  if (process.platform === 'darwin' && isDev) {
    try {
      const img = nativeImage.createFromPath(devIconPath);
      if (!img.isEmpty()) app.dock.setIcon(img);
    } catch {}
  }
  ensureDeviceId();
  // Forzar identidad local Arkaios si se desea
  ensureArkaiosAutologin();
  createWindow();
  // Aplicar pistas visuales Arkaios tras cargar
  if (mainWindow) {
    mainWindow.webContents.on('did-finish-load', () => applyArkaiosUIHints(mainWindow));
  }
  setupAutoUpdater(mainWindow);
  
  setTimeout(() => {
    autoUpdater.checkForUpdates().catch(err => {
      console.log('Auto-update check failed:', err);
    });
  }, 5000);
  
  if (store.get(constants.ACCESS_TOKEN_STORE_KEY)) {
    createOverlayWindow();
  }
  createAppMenu();
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
      createOverlayWindow();
    }
  });
  // Empujar el token local al renderer para evitar la pantalla de login
  try {
    const tok = store.get(constants.ACCESS_TOKEN_STORE_KEY);
    if (tok && mainWindow) {
      mainWindow.webContents.on('did-finish-load', () => {
        const script = `(() => {
          try {
            const tok = ${JSON.stringify(store.get(constants.ACCESS_TOKEN_STORE_KEY) || '')};
            if (window && window.electronAPI && typeof window.electronAPI.setToken === 'function') {
              window.electronAPI.setToken(tok);
            }
            // Si hay router por hash, ir al home
            try { if (location.hash && /login/i.test(document.body.textContent||'')) { location.hash = ''; } } catch(e){}
          } catch (e) {}
        })();`;
        try { mainWindow.webContents.executeJavaScript(script); } catch {}
        // Aplicar hints visuales Arkaios
        applyArkaiosUIHints(mainWindow);
      });
    }
  } catch (e) {
    console.warn('[Arkaios] No se pudo inyectar token al renderer:', e?.message || e);
  }
});

app.on('before-quit', () => {
  if (overlayHideTimeout) {
    clearTimeout(overlayHideTimeout);
    overlayHideTimeout = null;
  }
  cleanupExtractedBinary();
  app.isQuitting = true;
});

app.on('window-all-closed', () => {
  if (aiagentProcess && !aiagentProcess.killed) {
    kill(aiagentProcess.pid, 'SIGKILL', (err) => {
      if (err) console.error('❌ Failed to kill agent:', err);
      else console.log('[Agent stopped on app exit]');
    });
  }
  if (process.platform !== 'darwin' || app.isQuitting) app.quit();
});

      // Fallback fuerte: intentar redirigir periódicamente fuera de la ruta de login
      try {
        let tries = 0; const max = 20; // ~6s
        const iv = setInterval(() => {
          tries++;
          try {
            const isLoginView = /Login to NeuralAgent/i.test(document.body.textContent||'');
            if (isLoginView) {
              location.hash = '#/';
              window.dispatchEvent(new Event('popstate'));
              // ocultar contenedor visual si persiste
              const title = Array.from(document.querySelectorAll('h1,h2,h3,span,p'))
                .find(n=>/Login to NeuralAgent/i.test(n.textContent||''));
              if (title) { const root = title.closest('div'); if (root) root.style.display='none'; }
            } else {
              clearInterval(iv);
            }
          } catch {}
          if (tries>=max) { try { clearInterval(iv); } catch {} }
        }, 300);
      } catch {}
